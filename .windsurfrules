# Code Style & Architecture Principles

## Error Handling Philosophy
- **Fail-fast approach**: Let errors propagate up the call stack
- Use try-catch only at architectural boundaries (main entry points, user interaction handlers)
- Always provide user feedback before re-throwing errors
- Never silently swallow exceptions
- Throw meaningful errors with context: Include what failed and why
- No defensive "muddle through" logic when encountering unexpected states

## Code Organization & Architecture
- **IIFE wrapping**: Use `(() => { ... })()` for all injected content scripts to avoid polluting global namespace
- **Separation of concerns**:
  - UI logic in one layer (e.g., popup/view files)
  - Business/domain logic in separate files
  - No business logic in UI event handlers
- **Single Responsibility Principle**: Each function does one thing well
- **Keep functions small**: Aim for < 30 lines per function
- **Module-level state**: Declare state variables at top of module with clear purpose and initialization

## Configuration Management
- **Centralize all magic numbers** in a configuration object at the top of each file
- Configuration should include:
  - Debug flags for logging
  - Timeouts and wait intervals
  - Limits (max iterations, max retries)
  - Any tunable parameters
- Use UPPER_SNAKE_CASE for config keys
- No hardcoded values scattered through code
- Example pattern:
  ```javascript
  const CONFIG = {
      DEBUG: true,
      WAIT_INTERVAL_MS: 300,
      TIMEOUT_MS: 10000,
      MAX_ITERATIONS: 50
  };
  ```

## Naming Conventions
- **Be descriptive over terse**: `userProfileLink` not `link`, `totalItemCount` not `count`
- **Prefixing for clarity**:
  - UI element IDs: Use consistent prefix (e.g., `app-`, `ext-`, `ui-`)
  - Boolean variables: `is*`, `has*`, `should*`
  - Async functions: Consider `fetch*`, `load*`, `wait*` prefixes
- **Functions**:
  - Action functions: verb-noun format (`extractData`, `waitForElement`)
  - Query functions: `get*`, `find*`, `check*`
  - Boolean functions: `is*`, `has*`, `can*`
  - Debug/logging: Use consistent function name across project
- **Variables**:
  - `const` by default
  - `let` only when mutation is required
  - Descriptive pluralization for collections
  - Avoid abbreviations unless universally understood
- **Constants**: UPPER_SNAKE_CASE for true constants

## Control Flow & Code Structure
- **Minimize nesting**: Use guard clauses and early returns
  ```javascript
  // Preferred
  if (!condition) {
      handleError();
      return;
  }
  // ... main logic at base indent level

  // Avoid
  if (condition) {
      // ... deeply nested logic
  }
  ```
- **Loop selection**:
  - `for` loops when iterating a known range or need index
  - `forEach` for simple iterations with side effects
  - `map`/`filter`/`reduce` when transforming data (prefer immutability)
  - `while` only when termination condition is complex
- **Start counters at 0**: More conventional, aligns with array indexing
- **Array methods over manual loops**: Prefer functional approach when it improves clarity

## State Management
- Declare state at appropriate scope (module, function, or class level)
- Initialize to appropriate zero/empty values
- Use meaningful names that indicate purpose and scope
- Document state transitions in comments when non-obvious
- Avoid mutating state from multiple functions unless necessary

## Input Validation & Defensive Programming
- **Validate at boundaries**: Check inputs at function entry points
- **Strict validation**:
  - Verify URLs include expected paths, not just domains
  - Check array/object structure before accessing nested properties
  - Validate types when accepting external data
- **Fail immediately on invalid input**: Don't attempt to "fix" bad data
- **Meaningful error messages**: Include context about what was expected vs. received

## Asynchronous Code
- **Use `async/await` over Promise chains**: Improves readability and error handling
- **Always handle promise rejections**: Use try-catch with async/await
- **Use `Promise.all()` for parallel operations**: When operations are independent
- **Keep async functions focused**: Single responsibility applies here too
- **Avoid mixing callbacks and promises**: Choose one pattern and stick with it

## Chrome Extension Patterns
- **Script injection**:
  - Use `files:` parameter for non-trivial scripts
  - Use `func:` only for simple one-liners
  - Inject dependencies before main script when needed
- **Messaging**:
  - Include `type` or `action` field for message categorization
  - Handle `chrome.runtime.lastError` in all API callbacks
  - Use `chrome.storage.local` for persisting user preferences
  - Send status updates back to UI for long operations
- **Permissions**: Request minimal necessary permissions in manifest
- **Error boundaries**: Wrap API callbacks in try-catch or check for errors

## DOM Interaction (Web Scraping / Content Scripts)
- **Query selectors**:
  - Prefer semantic selectors (`[role="list"]`, `[aria-label="..."]`) over generated classes
  - Use stable attributes (data-*, id) when available
  - Avoid deeply nested selectors
- **Handle null results**: Always check if query methods returned elements
- **Text extraction**:
  - Use `innerText` when you want rendered, user-visible text
  - Use `textContent` when you need all text including hidden elements
  - Clean extracted text: normalize whitespace, remove unwanted suffixes
- **Wait for elements**: Implement proper waiting logic, not arbitrary timeouts
- **Cache DOM queries**: When accessing the same element multiple times

## Regex & String Processing
- **Global flag for multiple matches**: Use `/pattern/g` when replacing all occurrences
- **Normalize whitespace**: `replace(/\s+/g, ' ')` is a common pattern
- **Chain replacements**: Normalize in logical order (remove suffixes → collapse whitespace → trim)
- **Test edge cases**: Empty strings, special characters, Unicode

## File Generation & Downloads
- **Abstract common patterns**: Extract blob download logic if used multiple times
- **Filename conventions**:
  - Use descriptive names with timestamps
  - Format: `Description YYYY-MM-DD HHmm.ext`
  - Avoid special characters in filenames
- **Handle multiple formats**:
  - Structure code to easily add new export formats
  - Use same data structure for all formats
  - Load format-specific libraries conditionally

## External Library Integration
- **Conditional loading**: Only load libraries when needed based on user choice
- **Prefer CDN versions for extensions**: Smaller bundle size
- **Check library availability**: Verify library loaded before using
- **Wrap library calls**: Create abstraction layer for complex libraries

## Messaging Architecture
- **Structured messages**: Use consistent schema with fields like:
  - `type`: Category of message ('error', 'warning', 'info')
  - `action`: Specific action to trigger ('export_done', 'open_company_jobs', etc)
  - `message`: Human-readable text
  - `data`: Payload if needed
- **Message handlers**: Centralize in one place, use switch/if for routing
- **Bidirectional communication**: Content scripts → background → popup

## UI State Management
- **Explicit visibility control**: Don't rely on CSS alone for show/hide
- **Loading indicators**: Show during async operations, hide on completion
- **Status feedback**: Update UI for all state changes (loading, success, error)
- **CSS class conventions**: Use BEM-like modifier classes (`component--state`)

## Comments & Documentation
- **When to comment**:
  - Complex algorithms or non-obvious logic
  - TODOs for acknowledged future improvements
  - "Why" decisions that aren't obvious from code
  - API usage that isn't self-documenting
- **When NOT to comment**:
  - Obvious code
  - Restating function/variable names
  - Outdated comments
- **Keep comments updated**: When code changes, update or remove related comments
- **TODO format**: `// TODO: brief description of what needs to be done`

## Code Cleanup & Maintenance
- **Delete unused code immediately**: No commented-out blocks unless temporarily debugging
- **Remove console.logs before committing**: Except debug logs controlled by config flag
- **No commented-out alternatives**: Delete or choose one implementation
- **Keep codebase minimal**: Question whether each line is necessary
- **Consistent formatting**: Match existing indentation, spacing, brace style

## Testing & Debugging Considerations
- **Debug statements**:
  - Gate behind config flag
  - Include context: what's being logged and why
  - Use consistent prefix for filtering
- **Use `debugger;` during development**: Remove before committing
- **Test edge cases**: Empty results, network failures, slow connections, malformed data
- **Test in target environment**: Use browser-specific features appropriately

## Performance Considerations
- **Don't prematurely optimize**: Prioritize clarity over micro-optimizations
- **Profile before optimizing**: Measure actual bottlenecks
- **Common sense optimizations**:
  - Avoid querying DOM in loops
  - Cache frequently accessed values
  - Use appropriate data structures (Set for lookups, Map for key-value)
- **Async operations**: Don't block unnecessarily, but don't over-parallelize either

## Data Transformation Patterns
- **Immutable transformations**: Prefer `map`/`filter` over mutating arrays
- **Pipeline thinking**: Chain transformations logically
- **Validate before transform**: Check input structure before processing
- **Handle missing data**: Provide defaults or skip gracefully

## Consistency Principles
- **Follow existing patterns**: When adding to existing codebase
- **Apply new patterns consistently**: If you introduce a pattern, use it throughout
- **Match code style**: Brace placement, spacing, naming schemes
- **Use same terminology**: Don't mix synonyms (item/element, data/info)

## Code Review Checklist
Before committing, verify:
1. ✓ Errors fail-fast rather than being suppressed
2. ✓ All magic numbers are in configuration object
3. ✓ Variable names are descriptive and follow conventions
4. ✓ Nesting is minimized with guard clauses
5. ✓ Dead code and unused imports are removed
6. ✓ Debug logs are gated behind config flag
7. ✓ Comments explain "why" not "what"
8. ✓ Functions are small and focused
9. ✓ Async operations handle errors
10. ✓ Code would be understandable in 6 months

## Project-Specific Exceptions
Document any project-specific deviations from these rules here with justification.